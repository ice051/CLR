<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<body>
<div class="container">
<h1 class="hidetitle">在 Racket 中创造语言</h1>
<h2>有时候你得做个更好的捕鼠器。</h2>
<br>
<h3> Matthew Flatt, University of Utah </h3>
<br>
<p>为简单的工作选择合适的工具是很容易的：当需要更换玩具电池时，螺丝刀通常是最佳选择，而在文本文档中查找单词时，grep显然是最佳选择。对于更复杂的任务，工具的选择很少如此简单——对于编程任务更是如此，因为编程人员具有构建自己工具的无与伦比的能力。程序员经常通过创建新的工具程序来解决编程问题，比如从数据表生成源代码的脚本。</p>
<p>由于程序员经常构建特定任务的工具，使他们更有生产力的一种方法是给他们更好的工具制作工具。当工具采用程序生成器的形式时，这种想法会导致用于创建直接可扩展语言的库。甚至鼓励程序员从语言的角度来考虑问题，以更好地支持该任务。这种方法有时称为 <i>面向语言编程</i>。<sup>1</sup></p>
<p>Racket 既是一种编程语言，也是一种构建编程语言的框架。Racket 程序可以包含扩展该语言语法的定义，以便以后在同一个程序中使用，而且语言扩展可以打包为模块，以便在多个程序中使用。Racket 支持从相对简单的语言扩展到全新语言的平滑路径，因为一个编程工具，就像任何其他软件一样，很可能从简单开始，随着对语言需求的增加而增长。</p>
<p>作为示例任务，请实现一个文字冒险游戏（也称为交互式小说），玩家在游戏中输入命令，在虚拟世界中移动，并与对象互动：</p>
<p style="font-family:monospace;font-size:1.1em;"> <br>You're standing in a meadow. <br>There is a house to the north. <br>&gt; north <br>You are standing in front of a house. <br>There is a door here. <br>&gt; open door <br>The door is locked. <br>&gt; <br></p>
<p>为了让游戏变得有趣，程序员必须在虚拟世界中输入具有丰富行为的地点和事物。大多数编程语言都可以实现这个虚拟世界，但选择正确的语言结构(即正确的工具)来代表每个游戏元素是开发过程中的关键步骤。</p>
<p>正确的结构允许轻松地创建命令、位置和内容——避免容易出错的样板代码来设置世界的状态和连接——同时还允许使用编程语言的全部功能来实现行为。</p>
<p>在一种通用编程语言中，没有一种内置的语言结构是完美的。例如，位置和事物可以是对象，而命令可以实现为方法。然而，游戏玩家并不调用方法，而是输入命令，这些命令必须被解析并动态映射到位置和事物的响应。类似地，保存和加载游戏需要检查和恢复位置和事物的状态，这不仅是对象序列化的问题，还需要将变量设置为未编组的值(或者通过字典间接地从一个对象引用到另一个对象)。</p>
<p>一些编程语言包含结构(如重载或惰性)，聪明的程序员可以利用这些结构来编码特定于领域的语言。Racket 的设计更直接地解决这个问题；它为程序员提供使用新语法显式扩展编程语言的工具。有些任务只需要对核心语言进行很小的扩展，而另一些任务则可以从创建一种全新的语言中获益。Racket 支持频谱的两端，并且它这样做的方式允许一个平稳的进展从一端到另一端。当程序员对特定任务的需求或野心增长时，程序员可以利用更多的 Racket 统一框架进行语言扩展和构造。</p>
<p>这里的文本冒险例子说明从简单的 Racket 嵌入到独立的领域特定语言(包括 IDE 对语法着色的支持)的发展过程，并解释相关 Racket 的细节；不需要事先了解有关 Racket 的知识。想要更完整地介绍该语言的读者应该查阅 Racket 指南。<sup>2</sup></p>
<p>该示例是世界上多种意义上的“玩具”，但它也是行业实践的比例模型。大多数视频游戏开发人员都使用一种自定义语言，包括用于实现 <i>《神秘海域》</i> 视频游戏系列内容的基于 Racket 的语言。<sup>3</sup> 显然，当数以亿计的娱乐资金面临风险时，编程语言的选择就很重要——甚至到创建新的、特殊用途的语言的地步。</p>
<h3>朴素的 Racket 世界</h3>
<p>文本冒险游戏包含一组固定的 <i>地点</i> ，如草地、房子或沙漠，以及一组固定的 <i>事物</i> ，如门、钥匙或花。玩家在游戏世界中导航，并使用被解析为一个或两个单词的命令与事物进行互动：单个动词(即不及物动词，因为它没有目标对象)，如 <i>help</i> 或 <i> look</i> ； 或者动词后接事物名称(即及物动词后接名词)，如 <i>open door</i> 或 <i>get key</i> 。像 <i>north</i> 或 <i>in</i> 这样的导航词被视为动词。用户可以使用 <i>save</i> 和 <i>load</i> 动词保存游戏，这在任何地方都可以使用，并提示用户输入文件名。</p>
<p>为了在 Racket 中实现文本冒险游戏，首先需要声明三个游戏元素的结构类型：</p>
<p style="font-family:monospace;font-size:1.1em;"> <br><font color="#853D24">(</font>struct <font color="#262680">verb</font> <br> <font color="#853D24">(</font><font color="#262680">aliases</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#C2731F">; &nbsp;list of symbols</font> <br> &nbsp;<font color="#262680">Desc</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#C2731F">; &nbsp;string</font> <br> &nbsp;<font color="#262680">transitive?</font><font color="#853D24">)) &nbsp; &nbsp; &nbsp;</font><font color="#C2731F">; &nbsp;Boolean</font> <br> <br><font color="#853D24">(</font>struct <font color="#262680">thing</font> <br> <font color="#853D24">(</font><font color="#262680">name</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#C2731F">; &nbsp;symbol</font> <br> &nbsp;<font color="#853D24">[</font><font color="#262680">state</font><font color="#853D24"> #:mutable] &nbsp;</font><font color="#C2731F">; &nbsp;any value</font> <br> &nbsp;<font color="#262680">actions</font><font color="#853D24">))</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#C2731F">; &nbsp;list of verb-function &nbsp;pairs</font> <br> <br><font color="#853D24">(</font>struct <font color="#262680">place</font> <br> <font color="#853D24">(</font><font color="#262680">desc</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#C2731F">; &nbsp;string</font> <br> &nbsp;<font color="#853D24">[</font><font color="#262680">things</font><font color="#853D24"> #:mutable] </font><font color="#C2731F">; &nbsp;list of things</font> <br> &nbsp;<font color="#262680">actions</font><font color="#853D24">))</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#C2731F">; &nbsp;list of verb-function &nbsp;pairs</font> <br></p>
<p>Racket 是 Lisp 的一种方言，是 Scheme 的后裔，所以它的语法使用圆括号和一个自由的标识符语法(例如， <font face="Courier New">transitive?</font> 是一个标识符)。分号引入一个以换行符结束的注释。方括号可以与圆括号互换，但在某些上下文中按约定使用，例如用修饰符对字段名进行分组。修饰符 <font face="Courier New">#:mutable</font> 将字段声明为可变的，因为字段默认是不可变的。</p>
<p>代码中的第一个 <font face="Courier New">struct</font> 形式将动词绑定到函数，每个字段接受一个参数并创建一个动词实例。例如，可以将别名 <font face="Courier New">s</font> 定义为 <font face="Courier New">south</font> 动词</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define <font color="#262680">south</font> <font color="#853D24">(</font><font color="#262680">verb</font> <font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#218C21">'south 's</font><font color="#853D24">)</font> <font color="#218C21">"go south" #false</font><font color="#853D24">))</font> </p>
<p>Lisp 和 Racket 程序倾向于使用字符串作为显示给最终用户的文本——例如，动词描述，如 <font face="Courier New">"go south"</font> 。以单引号开头的 <i>符号</i> (例如， <font face="Courier New">'south), </font> 通常用于内部名称，如动词别名。</p>
<p>根据 <font face="Courier New">south</font> 和 <font face="Courier New">flower</font> 的定义，可以定义一个 <font face="Courier New">meadow</font> 的地方， <font face="Courier New">south</font> 动词可以将玩家带到 <font face="Courier New">desert</font> 的地方：</p>
<p style="font-family:monospace;font-size:1.1em;"> <br><font color="#853D24">(</font>define <font color="#262680">meadow</font> <font color="#853D24">(</font><font color="#262680">place</font> <font color="#218C21">"You're &nbsp;in a meadow."</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#262680">flower</font><font color="#853D24">)</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#853D24">(</font><font color="#0000FF">cons</font> <font color="#262680">south</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font>lambda <font color="#853D24">()</font> <font color="#262680">desert</font><font color="#853D24">)))))</font> <br></p>
<p> <font face="Courier New">list</font> 函数创建一个列表， <font face="Courier New">cons</font> 函数对两个值进行配对。 <font face="Courier New">cons</font> 函数通常将一个元素与一个列表配对，以形成一个新的列表，但这里 <font face="Courier New">cons</font> 将一个动词与实现该动词响应的函数配对。lambda 形式创建一个匿名函数，在本例中该函数要求零参数。</p>
<p>当一个动词的响应函数产生一个地点，如例子中的 <font face="Courier New">desert</font> ，游戏引擎将把玩家移到返回的地方。同时，游戏引擎支持保存和加载游戏状态，需要在地名和地名之间建立映射关系。(位置可以实现为可序列化的对象，但恢复游戏需要反序列化和更新 Racket 级变量，如 <font face="Courier New">meadow</font> 。) <font face="Courier New">record-element!</font> 函数实现名称和位置之间的映射：</p>
<p style="font-family:monospace;font-size:1.1em;"> <br><font color="#853D24">(</font>define <font color="#262680">names</font> <font color="#853D24">(</font><font color="#0000FF">make-hash</font><font color="#853D24">))</font> &nbsp; &nbsp;<font color="#C2731F">; symbol to place/thing</font> <br><font color="#853D24">(</font>define <font color="#262680">elements</font> <font color="#853D24">(</font><font color="#0000FF">make-hash</font><font color="#853D24">))</font> <font color="#C2731F">; &nbsp;place/thing to symbol</font> <br> <br><font color="#853D24">(</font>define <font color="#853D24">(</font><font color="#262680">record-element! name val</font><font color="#853D24">)</font> <br> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-set!</font> <font color="#262680">names name val</font><font color="#853D24">)</font> <br> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-set!</font> <font color="#262680">elements val name</font><font color="#853D24">))</font> <br> <br><font color="#853D24">(</font>define <font color="#853D24">(</font><font color="#262680">name-&gt;element name</font><font color="#853D24">)</font> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-ref</font> <font color="#262680">names name</font><font color="#853D24">))</font> <br><font color="#853D24">(</font>define <font color="#853D24">(</font><font color="#262680">element-&gt;name obj</font><font color="#853D24">)</font> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-ref</font> <font color="#262680">elements obj</font><font color="#853D24">))</font> <br></p>
<p>因此， meadow 的完整实现是：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define <font color="#262680">meadow</font> <font color="#853D24">(</font><font color="#262680">place ....</font><font color="#853D24">)</font><font color="#853D24">)</font> <font color="#C2731F">; as above</font> <br><font color="#853D24">(</font><font color="#262680">record-element!</font> <font color="#218C21">'meadow</font> <font color="#262680">meadow</font><font color="#853D24">)</font> </p>
<p>事物的定义和注册必须与位置的定义和注册基本相同。动词必须收集到一个列表中，以供游戏的命令解析器使用。最后，解析和执行引擎需要一组在任何地方都能工作的动词，每个动词都有其响应函数。所有这些部分构成游戏实现的有趣部分，而解析和执行引擎是几十行静态基础代码。</p>
<p>完整的游戏执行可以在线获得：<br></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/0-longhand/txtadv+world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/0-longhand/txtadv+world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/0-longhand/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/0-longhand/README.txt</a> <br> </p>
<p>请注意，构建虚拟世界所需的代码特别冗长。</p>
<h3>抽象语法</h3>
<p>尽管前一节的数据表示选择对于 Racket 程序来说很典型，但是 Racket 程序员不太可能编写直接定义和登记地点的重复代码，因为它包含很多样板 <font face="Courier New">list</font> 、 <font face="Courier New">cons</font> 和 <font face="Courier New">lambda</font> 。相反，一个 Racket 程序员会写 </p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-place meadow</font> <br> &nbsp; <font color="#218C21">"You're in a meadow." </font> <br> &nbsp; <font color="#853D24">[</font><font color="#262680">flower</font><font color="#853D24">]</font> <br> &nbsp; <font color="#853D24"> ([</font><font color="#262680">south desert</font><font color="#853D24">]))</font> </p>
<p>并且会添加一个 <font face="Courier New">define-place</font> 表单来使用基于模式的宏。这种宏最简单的形式是使用 <font face="Courier New">define-syntax-rule</font>： <br></p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id desc</i></font><font color="#853D24"> [</font><font color="#262680"><i>thng</i></font><font color="#853D24">] ([</font><font color="#262680"><i>vrb &nbsp;expr</i></font><font color="#853D24">]))</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp;(</font>define <font color="#262680"><i>id </i></font><font color="#853D24">(</font><font color="#262680">place <i> desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list </font><font color="#262680"><i>thng</i></font><font color="#853D24"> )</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list </font><font color="#853D24">(</font><font color="#0000FF">cons </font><font color="#262680"><i>vrb </i></font><font color="#853D24">(</font>lambda <font color="#853D24">() </font><font color="#262680"><i>expr</i></font><font color="#853D24"> )))))</font> <br><font color="#853D24"> &nbsp; &nbsp;(</font><font color="#262680">record-element! </font><font color="#218C21">'</font><font color="#262680"><i>id &nbsp;id</i></font><font color="#853D24"> )))</font> <br></p>
<p>紧接在 <font face="Courier New">define-syntax-rule</font> 之后的形式是 <i>模式</i> ，模式之后的形式是 <i>模板</i> 。使用与其模式匹配的宏会被宏的模板替换，对匹配的 <i>模式变量</i> 做模替换。该模式中的 <font face="Courier New"><i>id</i></font><i> 、 </i><font face="Courier New"><i>desc</i></font><i> 、 </i><font face="Courier New"><i>thng</i></font><i> 、 </i><font face="Courier New"><i>vrb</i></font> 和 <font face="Courier New"><i>expr</i></font> 标识符都是模式变量。</p>
<p>请注意， <font face="Courier New">define-place</font> 表单不能是函数。通常，在 <font face="Courier New">south</font> 之后的 <font face="Courier New">desert</font> 表达式必须在输入 <font face="Courier New">south</font> 命令后才计算。更重要的是，表单应绑定变量 <font face="Courier New">meadow</font> ，以便命令的 Racket 表达式可以直接引用该位置。此外，变量的源名称(而不是它的值)用于注册元素表中的位置。</p>
<p>到目前为止， <font face="Courier New">define-place</font> 宏只匹配一个位置中的一个事物内容、一个动词和响应表达式。要概括任何数量的事物、动词和表达式，请要在模式中添加省略号：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [</font><font color="#262680"><i>thng</i></font> ...<font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([</font><font color="#262680"><i>vrb expr</i></font><font color="#853D24"> ] &nbsp;</font>...<font color="#853D24">))</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680">id</font><font color="#853D24"> &nbsp;(</font><font color="#262680">place</font> <font color="#262680"><i>desc</i></font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#262680"><i>thng</i></font> &nbsp;...<font color="#853D24">)</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#853D24">(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#0000FF">cons</font> <font color="#262680"><i>vrb</i></font><font color="#853D24"> (</font>lambda<font color="#853D24"> () </font><font color="#262680"><i>expr</i></font><font color="#853D24"> ))</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<font color="#853D24">)))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-element!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> </p>
<p>省略号的作用很明显，有了这个广义的 <font face="Courier New">define-place</font> ，可以把仙人掌和钥匙都放在沙漠里，然后再呆在沙漠中以响应 <font face="Courier New">north</font> 以外的方向动词：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-place desert <br> &nbsp;<font color="#218C21">"You're in a desert."</font> <br> &nbsp;<font color="#853D24">[</font>cactus key<font color="#853D24">]</font> <br> &nbsp;<font color="#853D24">([</font>north meadow<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">[</font>south desert<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">[</font>east desert<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">[</font>west desert<font color="#853D24">]))</font> </p>
<p>对于事物的宏也同样简单：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-thing</font> <font color="#262680"><i>id</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [</font><font color="#262680"><i>vrb expr</i></font><font color="#853D24"> ] &nbsp;</font>...<font color="#853D24">)</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680">id</font> <br> &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font><font color="#262680">thing </font><font color="#218C21">'id #false </font><font color="#853D24">(</font><font color="#0000FF">list </font><font color="#853D24">(</font><font color="#0000FF">cons </font><font color="#262680"><i>vrb</i> </font><font color="#853D24">(</font>lambda <font color="#853D24">() </font><font color="#262680"><i>expr</i></font><font color="#853D24"> )) </font>...<font color="#853D24">)))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-thing!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> <br></p>
<p>动词要稍微复杂一些，因为您想使简单的动词特别紧凑以指定它，并且对于不及物动词需要一种模式，而对及物动词则需要另一种模式。下面的例子说明了目标语法：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-verbs all-verbs</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">quit</font><font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">north</font><font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> n<font color="#853D24">) </font><font color="#218C21">"go &nbsp;north"</font><font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">knock</font> _<font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">get</font> _<font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> grab &nbsp;take<font color="#853D24">) </font><font color="#218C21">"take"</font><font color="#853D24">])</font> <br></p>
<p>这个例子定义四个动词： <font face="Courier New">quit</font> 作为不及物动词，没有别名；作为不及物动词的 <font face="Courier New">north</font> ，别名 <font face="Courier New">n</font> ，首选的描述是 <font face="Courier New">go north</font> ； <font face="Courier New">knock</font> 作为及物动词(如下划线所示)，没有别名； <font face="Courier New">get</font> 作为及物动词，有 <font face="Courier New">grab</font> 和 <font face="Courier New">take</font> 的别名，并且 <font face="Courier New">take</font> 是首选描述。最后，所有这些动词都被收集到一个列表中，绑定到 <font face="Courier New">all-verbs</font> ，以便游戏命令解析器使用。</p>
<p>实现 <font face="Courier New">define-verbs</font> 形式需要更通用的模式匹配，以支持不同形状的动词规范，并将 <font face="Courier New">=</font> 和 <font face="Courier New">_</font> 匹配为字面量。 <font face="Courier New">define-verbs </font> 的实现可以将处理单个动词的工作推迟到 <font face="Courier New">define-one-verb</font> 宏，该宏使用 <font face="Courier New">define-syntax</font> 和 <font face="Courier New">syntax-rules</font>：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax <font color="#262680">define-one-verb</font> <br><font color="#853D24"> &nbsp;(</font>syntax-rules<font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> _<font color="#853D24">)</font> <br> &nbsp; &nbsp;<font color="#853D24">[(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font><font color="#853D24"> (</font><font color="#0000FF">=</font> <font color="#262680"><i>alias</i></font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> &nbsp;(</font><font color="#262680">verb</font><font color="#853D24"> (</font><font color="#0000FF">list</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font> <font color="#218C21">'alias</font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font> <font color="#218C21">#false</font><font color="#853D24">))] &nbsp; &nbsp; </font> <br><font color="#853D24"> &nbsp; &nbsp; [(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font> _<font color="#853D24"> (</font><font color="#0000FF">=</font> <font color="#262680"><i>alias</i></font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> &nbsp;(</font><font color="#262680">verb</font><font color="#853D24"> (</font><font color="#0000FF">list</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font> <font color="#218C21">'alias</font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font> <font color="#218C21">#true</font><font color="#853D24">))] &nbsp; </font> <br><font color="#853D24"> &nbsp; &nbsp; [(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font><font color="#853D24">)</font> <br> &nbsp; &nbsp; <font color="#853D24"> &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> (</font><font color="#262680">verb</font><font color="#853D24"> (</font><font color="#0000FF">list</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;) (</font><font color="#0000FF">symbol-&gt;string</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;) </font><font color="#218C21">#false</font><font color="#853D24">))]</font> <br><font color="#853D24"> &nbsp; &nbsp; [(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font> _<font color="#853D24">)</font> <br> &nbsp; &nbsp; <font color="#853D24"> &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> (</font><font color="#262680">verb </font><font color="#853D24">(</font><font color="#0000FF">list </font><font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> ) (</font><font color="#0000FF">symbol-&gt;string</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;) </font><font color="#218C21">#true</font><font color="#853D24">))]))</font> <br></p>
<p><font face="Courier New">syntax-rules</font> 后面的圆括号中的 <font face="Courier New">=</font> 和 <font face="Courier New">_</font> 表示 <font face="Courier New">=</font> 和 <font face="Courier New">_</font> 在后面的模式中是字面量，而不是模式变量。每个模式之后都有一个对应的模板。因此，在</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-verbs all-verbs</font> <br><font color="#262680"> &nbsp; ....</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">get</font> _<font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> grab take<font color="#853D24">) </font><font color="#218C21">"take"</font><font color="#853D24">])</font> <br></p>
<p> <font face="Courier New">define-verbs</font> 展开式将最后一个从句变成一个 <font face="Courier New">define-one-verb</font> 用法：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-one-verb get</font> _<font color="#853D24"> (</font><font color="#0000FF">=</font> <font color="#262680">grab take</font><font color="#853D24">) </font><font color="#218C21">"take"</font><font color="#853D24">)</font> </p>
<p>这符合 <font face="Courier New">one-verb</font> 的第一种模式，扩展为：</p>
<p style="font-family:monospace;font-size:1.1em;"> (define <font color="#262680">get</font> (<font color="#262680">verb</font> (<font color="#0000FF">list</font> <font color="#218C21">'get 'grab 'take</font>) <font color="#218C21">"take" #true</font>))</p>
<p>最后，创建一个 <font face="Courier New">define-everywhere</font> 形式来定义在世界各地工作的动词响应，如 <font face="Courier New">save</font> 和 <font face="Courier New">load</font> 这样的动词需要：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-everywhere</font> <font color="#262680"><i>id</i></font><font color="#853D24"> ([</font><font color="#262680"><i>vrb &nbsp;expr</i></font><font color="#853D24"> ] </font>...<font color="#853D24">)) &nbsp; </font> <br><font color="#853D24"> &nbsp; (</font>define <font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#0000FF">cons</font> <font color="#262680"><i>vrb</i></font><font color="#853D24"> (</font>lambda<font color="#853D24"> () </font><font color="#262680"><i>expr</i></font><font color="#853D24"> )) </font>...<font color="#853D24">)))</font> <br> <br><font color="#853D24">(</font><font color="#262680">define-everywhere &nbsp;everywhere-actions</font> <br><font color="#853D24"> &nbsp; ([</font><font color="#262680">quit</font><font color="#853D24"> &nbsp;(</font>begin<font color="#853D24"> &nbsp;(</font><font color="#0000FF">printf</font> <font color="#218C21">"Bye!\n"</font><font color="#853D24">) (</font><font color="#0000FF">exit</font><font color="#853D24">))]</font> <br><font color="#853D24"> &nbsp;&nbsp; [</font><font color="#262680">save</font><font color="#853D24"> &nbsp;(</font><font color="#262680">save-game</font><font color="#853D24">)]</font> <br><font color="#853D24"> &nbsp;&nbsp; [</font><font color="#262680">load</font><font color="#853D24"> &nbsp;(</font><font color="#262680">load-game</font><font color="#853D24">)]</font> <br><font color="#262680"> &nbsp;&nbsp; ....</font><font color="#853D24">))</font> <br></p>
<p> <font face="Courier New">define-place</font> 、 <font face="Courier New">define-thing</font> 和 <font face="Courier New">define-verb</font> 宏都是<i>语法抽象 </i> 的例子。它们对重复的语法模式进行抽象，这样程序员就可以避免样板代码，而专注于创建有趣的动词、位置和事物。</p>
<p>修改后的游戏实现，它有一个紧凑和可读的虚拟世界的实现，可以在线获得：</p>
<p><a href="https://queue.acm.org/downloads/2011/racket/1-monolith/txtadv+world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/1-monolith/txtadv+world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/1-monolith/" target="_blank">http://queue.acm.org/downloads/2011/racket/1-monolith/</a>README.txt <br> </p>
<h3>语法扩展</h3>
<p>如果一个业余程序员对编写一款文本冒险游戏感兴趣，他可能会停止扩展语言。然而，如果文本冒险引擎可以在多个世界中重复使用，那么程序员很可能会从语法抽象向 <i>语法扩展</i> 迈出一步。</p>
<p>抽象和扩展之间的区别部分在于观察者的眼光，但是扩展建议使用诸如 <font face="Courier New">place</font> 和 <font face="Courier New">record-element!</font> 这样的功能。可以保持私有，而 <font face="Courier New">define-place</font> 则导出，以便在与实现无关的语义在世界定义模块中使用。在世界定义模块中，诸如 <font face="Courier New">define-place</font> 之类的宏与诸如 <font face="Courier New">define</font> 和 <font face="Courier New">lambda</font> 之类的内置表单具有相同的状态。</p>
<p>要进行这种转换，可以将 <font face="Courier New">define-verbs</font> 、 <font face="Courier New">define-place</font> 、<font face="Courier New">define-thing</font> 和 <font face="Courier New">define-everywhere</font> 定义放在它们自己的模块中，命名为 world.rkt。</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">racket</font> <br><font color="#853D24">(</font>require <font color="#218C21">"txtadv.rkt"</font><font color="#853D24">)</font> <br> <br><font color="#853D24">(</font><font color="#262680">define-verbs ....</font><font color="#853D24">)</font> <br><font color="#853D24">(</font><font color="#262680">define-everywhere ....</font><font color="#853D24">)</font> <br><font color="#853D24">(</font><font color="#262680">define-thing ....</font><font color="#853D24">) </font>... <br><font color="#853D24">(</font><font color="#262680">define-place ....</font><font color="#853D24">) </font>... <br></p>
<p>这个模块导入 txtadv.rkt ，它导出 <font face="Courier New">define-verbs</font> 等，以及用于动词响应的函数，如 <font face="Courier New">save-game</font> 和 <font face="Courier New">load-game</font> 。与此同时, txtadv.rkt 将实现世界数据类型的结构和其他函数保持私有。</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">racket</font> <br><font color="#853D24">(</font>provide <font color="#262680">define-verbs &nbsp;define-thing</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">define-place define-everywhere</font> <br> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">save-game</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">load-game</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">....</font><font color="#853D24">)</font> <br> <br><font color="#853D24">(</font>struct <font color="#262680">verb &nbsp;....</font><font color="#853D24">)</font> <br><font color="#262680">....</font> <br><font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-verbs &nbsp;....</font><font color="#853D24">) </font><font color="#262680">....</font><font color="#853D24">)</font> <br><font color="#262680">....</font> <br></p>
<p>启动每个模块的 <font face="Courier New">#lang racket</font> 行表明该模块是用 <font face="Courier New">racket</font> 语言实现的。在 world.rkt 中， <font face="Courier New">require</font> 还同时导入 txtadv.rkt 模块导出的语法扩展和函数。</p>
<p>由于宏绑定是 Racket 语言的一部分，而不是作为单独的预处理器来实现，宏绑定可以像处理变量绑定一样处理模块导入和导出。特别是，由于词法作用域的规则， <font face="Courier New">define-verbs</font> 宏的定义可以看到 <font face="Courier New">verb</font> 构造函数，而 world.rkt 模块中的代码由于相同的作用域规则不能直接访问 <font face="Courier New">verb</font> 。由于 world.rkt 中 <font face="Courier New">define-verbs</font> 的使用扩展到 <font face="Courier New">verb</font> 的使用，为了在宏扩展的情况下保持词汇范围，需要大量的语言机制，但结果是语法扩展对程序员来说很容易。</p>
<p>模块化的游戏实现可以在线获得：</p>
<p><a href="https://queue.acm.org/downloads/2011/racket/2-modules/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/2-modules/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/2-modules/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/2-modules/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/2-modules/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/2-modules/README.txt</a> <br> </p>
<h3>模块语言</h3>
<p>尽管 world.rkt 模块不能直接访问构造函数，如 <font face="Courier New">verb</font> ，但该模块仍然可以访问所有的 Racket 语言，以及通过 <font face="Courier New">require</font> ，任何其他模块都可导出。为了确保 world.rkt 的假设得到满足，可能需要对 txtadv.rkt 施加更多的约束。</p>
<p>为了进行进一步的控制，可以将 txtadv.rkt 从导出语言扩展的模块转换为导出语言的模块。然后， world.rkt 不是以 <font face="Courier New">#lang racket</font> 开头，而是以如下开头</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">s-exp</font> <font color="#218C21">"txtadv.rkt"</font></p>
<p>目前， <font face="Courier New">s-exp</font> 表示 world.rkt 的语言使用S表达式表示法(即括号)，而 txtadv.rkt 定义语法形式。后来，S表达式和语法形式规范被组合成一个单独的名称，类似于 <font face="Courier New">#lang racket</font> 。</p>
<p>随着 world.rkt 改变，可以改变 txtadv.rkt 从 Racket 导出一切：</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">racket</font> <br><font color="#853D24">(</font>provide <font color="#262680">define-verbs &nbsp;....</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font>all-from-out <font color="#262680">racket</font><font color="#853D24">))</font> <br><font color="#262680">....</font> </p>
<p>可以用 <font face="Courier New">(except-out (all-from-out racket) require)</font> 从 world.rkt 中保留 <font face="Courier New">require</font> 形式，而不是 <font face="Courier New">(all-from-out racket)</font> 。另外，也可以不使用 <font face="Courier New">all-from-out</font> ，将绑定命名为预扣，而可以显式地仅从 Racket 中导出某些片段。</p>
<p>txtadv.rkt 的导出完全确定 world.rkt 中可用的绑定——不仅是函数，还包括 <font face="Courier New">require</font> 或 <font face="Courier New">lambda</font> 这样的语法形式。例如， txtadv.rkt 可以提供一个 <font face="Courier New">lambda</font> 绑定到 world.rkt ，它实现一种不同于通常 <font face="Courier New">lambda</font> 的函数，比如具有延迟求值的函数。</p>
<p>更常见的是，模块语言可以替换 <font face="Courier New">#%module-begin</font> 形式，它隐式地包装模块的主体。具体来说， txtadv.rkt 可以提供一个替代的 <font face="Courier New">#%module-body</font> ，强制 world.rkt 有一个单独的 <font face="Courier New">define-verbs</font> 形式、一个单独的 <font face="Courier New">define-everywhere</font> 形式、一系列 <font face="Courier New">define-thing</font> 声明和一系列 <font face="Courier New">define-place</font> 声明；如果 world.rkt 有任何其他形式，它可以作为语法错误被拒绝。这些约束可以强制限制 txtadv.rkt 语言的功能，但是它们也可以用于提供特定领域的检查和错误消息。</p>
<p>使用 txtadv.rkt 语言实现的游戏可以在线获得：</p>
<p><a href="https://queue.acm.org/downloads/2011/racket/3-module-lang/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/3-module-lang/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/3-module-lang/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/3-module-lang/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/3-module-lang/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/3-module-lang/README.txt</a> <br> </p>
<p>实现中的 <font face="Courier New">#%module-begin</font> 替换需要 <font face="Courier New">define-verbs</font> 后跟 <font face="Courier New">define-everywhere</font> ，然后允许任何数量的其他声明。模块必须以 place 表达式结束，它作为游戏的开始位置。</p>
<h3>静态检查</h3>
<p> <font face="Courier New">define-verb</font> 、 <font face="Courier New">define-place</font> 和 <font face="Courier New">define-thing</font> 形式绑定 Racket 名称的方式与其他 Racket 定义相同，每个对动词、位置或物体的引用都是对已定义名称的 Racket 级引用。这种方法使得在 Racket 中实现的 <font face="Courier New">verb-response</font> 表达式很容易指向虚拟世界中的其他事物和地方，然而，这也意味着误用引用会导致运行时错误。例如，错误地将 <font face="Courier New">desert</font> 描述为</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-place room <br> &nbsp; <font color="#218C21">"You're in the house." </font> <br> &nbsp; <font color="#853D24">[</font>trophy desert<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">([</font>out house-front<font color="#853D24">]))</font> <br></p>
<p>只有当玩家进入 <font face="Courier New">room</font> 时，才会触发失败，而当游戏引擎试图在这个地方展示东西时也会失败。</p>
<p>许多语言都提供类型检查或其他静态类型，以确保不会出现某些运行时错误。 Racket 宏可以实现带有静态检查的语言，宏甚至可以实现在基本语言中执行静态检查的语言扩展，这些检查与运行时检查类似。具体来说，可以调整 <font face="Courier New">define-verb</font> 、 <font face="Courier New">define-place</font> 和 <font face="Courier New">define-thing</font> 来检查某些引用，例如要求 place 中的初始事物列表只包含定义为事物的名称。类似地，可以检查作为响应动词使用的名称，以确保它们声明为动词，适当地具有及物性或不及物性。</p>
<p>实现静态检查通常需要比模式匹配宏更具表现力的宏。在 Racket 中，任意的编译时代码可以扮演语法形式扩展器的角色，因为宏定义的最一般形式是</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax <font color="#262680">id <i> transformer-expr</i></font><font color="#853D24"> )</font></p>
<p>其中， <font face="Courier New">transformer-expr</font> 是一个生成函数的编译时表达式。函数必须接受一个参数，它是使用 <font face="Courier New">id</font> 语法形式的表示，函数必须产生使用扩展的表示。同样， <font face="Courier New">define-syntax-rule</font> 是 <font face="Courier New">define-syntax</font> 和 <font face="Courier New">syntax-rules</font> 的简写， <font face="Courier New">syntax-rules</font> 是带有一个参数的函数的简写，该参数将特定形状的表达式(匹配模式)分离开来，并为结果构造一个新的表达式(基于模板)。</p>
<p> <font face="Courier New"><i>transformer-expr</i></font> 使用的编译时语言可能与周围的运行时语言不同，但 <font face="Courier New">#lang racket</font> 为编译时表达式的语言播下种子，其语言本质上与运行时表达式的语言相同。可以使用 <font face="Courier New">(require (for-syntax ....))</font> 而不是 <font face="Courier New">require</font> 将新的绑定引入编译时阶段，也可以通过 <font face="Courier New">begin-for-syntax</font> 包装的定义将本地绑定添加到编译时阶段。</p>
<p>例如，要静态地检查动词、事物和位置， <font face="Courier New">begin-for-syntax</font> 可以定义一个新的类型化结构：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>begin-for-syntax <br><font color="#853D24"> &nbsp;(</font>struct <font color="#262680">typed</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">id</font> &nbsp; &nbsp; <font color="#C2731F">; an identifier</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp;</font><font color="#262680">type</font><font color="#853D24">)</font>&nbsp; <font color="#C2731F">; &nbsp;a string</font> <br><font color="#853D24"> &nbsp; &nbsp; #:property </font><font color="#0000FF">prop:procedure </font><font color="#853D24">(</font>lambda <font color="#853D24">(</font><font color="#262680">self stx</font><font color="#853D24">) (</font><font color="#262680">typed-id self</font><font color="#853D24">))))</font> </p>
<p> <font face="Courier New"><i>标识符</i></font> 被写成一个符号，但带有 <font face="Courier New">#</font> 前缀，这样</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>typed #'gen-desert <font color="#218C21">"place"</font><font color="#853D24">)</font></p>
<p>将绑定 <font face="Courier New">gen-desert</font> 关联到类型 <font face="Courier New">"place"</font> 。在 <font face="Courier New">typed</font> 声明中的 <font face="Courier New">#:property prop:procedure</font> 子句使类型化实例充当函数(原因在后面解释)。该函数除了隐含的 <font face="Courier New">self</font> 参数外还接受一个参数，但它忽略该参数并返回 <font face="Courier New">typed</font> 实例的 <font face="Courier New">id</font> 。</p>
<p>可以通过更改 <font face="Courier New">define-place</font> 表单来使用 <font face="Courier New">typed</font> ，将一个位置名称 <font face="Courier New"><i>id</i></font> 绑定到编译时的 <font face="Courier New">typed</font> 记录。同时， <font face="Courier New">define-place</font> 将生成的名称 <font face="Courier New"><i>gen-id</i></font> 绑定到运行时的 place 记录：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id</i></font> <font color="#262680">....</font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680"><i>gen-id</i></font><font color="#853D24"> (</font><font color="#262680">place &nbsp;....</font><font color="#853D24">)) </font><font color="#C2731F">; as before</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font>define-syntax <font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;(</font><font color="#262680">typed</font> #'<font color="#262680"><i>gen-id</i></font> <font color="#218C21">"place"</font><font color="#853D24">))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-element!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> <br></p>
<p>由于 <font face="Courier New">typed</font> 记录作为一个函数， <font face="Courier New"><i>id</i></font> 的使用扩展到 <font face="Courier New"><i>gen-id</i></font> ，所以 <font face="Courier New"><i>id</i></font> 仍然可以直接引用 <font face="Courier New">place</font> 。与此同时，其他宏可以查看 <font face="Courier New"><i>id</i></font> 绑定并确定其展开式具有 <font face="Courier New">"place"</font> 类型。<br></p>
<p>其他宏使用 <font face="Courier New">check-type macro</font> 检查类型。 <font face="Courier New">check-type</font> 的实现在完整的在线代码中，但它的基本特性是使用编译时函数 <font face="Courier New">syntax-local-value</font> 来获取标识符的编译时值；然后 <font face="Courier New">check-type</font> 宏使用 <font face="Courier New">typed?</font> 来检查编译时值是否为类型声明，在这种情况下，它使用 <font face="Courier New">typed-type</font> 来检查声明的类型是否为期望的类型。只要类型检查通过， <font face="Courier New">check-type</font> 就会扩展到它的第一个参数。</p>
<p> <font face="Courier New">define-place</font> 宏使用 <font face="Courier New">check-typed</font> 来检查 <font face="Courier New">place</font> 中的事物列表是否只包含定义为事物的名称。 <font face="Courier New">define-place</font> 宏还使用 <font face="Courier New">check-typed</font> 来检查在 <font face="Courier New">place</font> 中有响应的动词是否定义为不及物动词：</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id</i></font> <br><font color="#262680"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i> desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [</font><font color="#262680"><i>thng</i></font> &nbsp;...<font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([</font><font color="#262680"><i>vrb expr</i></font><font color="#853D24"> ] &nbsp;</font>...<font color="#853D24">))</font> <br> &nbsp;<font color="#853D24">(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680"><i>gen-id</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; (</font><font color="#262680">place</font> <font color="#262680"><i>desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#262680">check-type</font> <font color="#262680"><i>thng</i></font> <font color="#218C21">"thing"</font><font color="#853D24">) &nbsp;</font>...<font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#0000FF">cons</font><font color="#853D24"> (</font><font color="#262680">check-type</font> <font color="#262680"><i>vrb</i></font> <font color="#218C21">"intransitive &nbsp;verb"</font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</font>lambda<font color="#853D24"> &nbsp;() </font><font color="#262680"><i>expr</i></font><font color="#853D24"> ))</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<font color="#853D24">)))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font>define-syntax <font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;(</font><font color="#262680">typed</font> #'<font color="#262680"><i>gen-id</i></font> <font color="#218C21">"place"</font><font color="#853D24">))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-element!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> <br></p>
<p> <font face="Courier New">define-one-verb</font> 宏必须以类似的方式声明每个动词为 <font face="Courier New">"transitive verb"</font> 或 <font face="Courier New">"intransitive verb"</font> 。 <font face="Courier New">define-thing</font> 宏更改绑定声明为 <font face="Courier New">"thing"</font> ，并检查每个处理过的动词是否定义为 <font face="Courier New">"transitive verb"</font> 。</p>
<p>带有静态检查的游戏代码可以在线获得： </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/4-type/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/4-type/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/4-type/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/4-type/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/4-type/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/4-type/README.txt</a> <br> </p>
<p> <font face="Courier New">check-form</font> 的实现使用 <font face="Courier New">syntax-case</font> ，它提供 <font face="Courier New">syntax-rules</font> 的模式匹配功能，但将每个模式与一个表达式配对，而不是一个固定的模板。</p>
<h3>新语法</h3>
<p>一个为其他 Racket 程序员定义自定义文本冒险语言的 Racket 程序员很可能在此时停止。但是，如果文本冒险语言是由不太熟悉 Racket 的人使用的，那么可能需要使用不同的符号。例如，其他人可能更喜欢 world.rkt 的如下表示法：</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">reader</font><font> &nbsp;</font><font color="#218C21">"txtadv-reader.rkt"</font> <br> <br><font color="#262680">===VERBS===</font> <br><font color="#262680">north</font><font>,</font><font color="#262680"> &nbsp;n</font> <br><font color="#218C21"> &nbsp;"go &nbsp;north"</font> <br><font color="#262680">get </font><font>_,</font><font color="#262680"> &nbsp;grab </font><font>_,</font><font color="#262680"> &nbsp;take </font><font>_</font> <br><font color="#262680"> &nbsp;</font><font color="#218C21">"take"</font> <br><font color="#262680">....</font> <br><font color="#262680">===EVERYWHERE===</font> <br><font color="#262680">save</font> <br><font color="#262680"> &nbsp;</font><font color="#853D24">(</font><font color="#262680">save-game</font><font color="#853D24">)</font> <br><font color="#262680">load</font> <br><font color="#853D24"> &nbsp;(</font><font color="#262680">load-game</font><font color="#853D24">)</font> <br><font color="#262680">....</font> <br><font color="#262680">===THINGS===</font> <br><font color="#262680">---cactus---</font> <br><font color="#262680">get</font> <br><font color="#262680"> &nbsp;</font><font color="#218C21">"Ouch!"</font> <br><font color="#262680">....</font> <br><font color="#262680">===PLACES===</font> <br><font color="#262680">---desert---</font> <br><font color="#218C21">"You're &nbsp;in a desert."</font> <br><font color="#853D24"> &nbsp;[</font><font color="#262680">cactus</font><font>,</font> <font color="#262680">key</font><font color="#853D24">]</font> <br><font color="#262680">north &nbsp; &nbsp;start</font> <br><font color="#262680">south &nbsp; &nbsp;desert</font> <br><font color="#262680">....</font> <br></p>
<p>在这种表示法中，与诸如 <font face="Courier New">define-verbs</font> 和 <font face="Courier New">define-everywhere</font> 之类的形式不同，程序的各个部分是通过诸如 <font face="Courier New">===VERBS===</font> 和 <font face="Courier New">===EVERYWHERE===</font> 等标记引入的。 <font face="Courier New">===VERBS===</font> 部分中的名称隐式地定义动词，后面用逗号分隔的序列列出别名，然后是动词的可选描述。类似地， <font face="Courier New">===EVERYWHERE===</font> 节中的每个名称都隐式地定义对谓词的响应；响应仍然被写成 Racket 表达式，但如果需要的话，它们可以用任何替代的符号表示。每个事物和地点都由它自己的子部分定义，比如 <font face="Courier New">---cactus---</font> ，每个对象的动词响应方式与 <font face="Courier New">===EVERYWHERE===</font> 相同。</p>
<p>非S表达式语法在 world.rkt 中启用，是以 <font face="Courier New">#lang reader "txtadv-reader.rkt"</font> 开始，而不是 <font face="Courier New">#lang s-exp "txtadv.rkt"</font> 。 <font face="Courier New">reader</font> 语言构造函数与 <font face="Courier New">s-exp</font> 语言构造函数不同，它将程序文本的解析延迟到指定模块导出的任意解析函数，在本例中是 <font face="Courier New">txtadv-reader.rkt</font> 。 <font face="Courier New">txtadv-reader.rkt</font> 的解析器负责处理其余文本并将其转换为S表达式表示法，包括引入 <font face="Courier New">txtadv.rkt</font> 作为已解析 <font face="Courier New">world.rkt</font> 模块的模块语言。</p>
<p>更准确地说，读取器函数将输入解析为一个语法对象，该对象类似于一个S表达式，包含丰富的词汇上下文和源位置信息。它还充当宏转换器参数和结果的代码表示。语法对象抽象提供字符级解析和树结构宏转换的清晰分离。语法对象的源位置部分自动将宏展开的结果连接回原始源；如果在 <font face="Courier New">world.rkt</font> 生成的代码中发生运行时错误，那么错误可以指向相关的源代码。</p>
<p>带有非圆括号语法的游戏代码可以在线获得：</p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/txtadv-reader.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/txtadv-reader.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/README.txt</a> <br> </p>
<p> <font face="Courier New">txtadv-reader.rkt</font> 中的解析器是使用正则表达式以一种特别原始的方式实现。Racket 分发版包括更好的解析工具，比如Lex和yacc风格的解析器生成器。</p>
<h3>IDE 支持</h3>
<p>S表达式表示法的好处之一是，编程环境的功能很容易适应语法扩展，因为语法着色和圆括号匹配可以独立于宏扩展。其中一些优点与描述世界的新语法保持一致，因为解析器使用标识符保存源位置，而且代码最终扩展为 Racket 级绑定形式。例如，DrRacket 中的 Check Syntax 按钮可以自动绘制从 <font face="Courier New">cactus</font> 绑定实例到 <font face="Courier New">cactus</font> 绑定使用的箭头。</p>
<p>DrRacket 为语言实现者在 IDE 特性方面提供更多帮助，比如语法着色，这些特性依赖于语言的字符级语法。完成这部分示例文本冒险语言需要两个步骤：</p>
<p>1. 将该语言的阅读器安装为 <font face="Courier New">txtadv</font> 库集合，而不是依赖于相对路径，如 <font face="Courier New">txtadv-reader.rkt</font> 。移至库集合的名称空间后，DrRacket 和程序可以就所使用的语言达成一致（而无需对IDE进行项目样式的配置）。</p>
<p>2.  <font face="Courier New">txtadv</font> 增加函数，用于标识对该语言的其他支持，例如实现动态语法着色的模块。同样，由于 DrRacket 和模块使用相同的模块语言规范，语法颜色可以精确地定制为模块的语言和内容。</p>
<p>游戏代码与 DrRacket 插件的语法着色可以在线获得：</p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/world.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/README.txt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/lang/color.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/lang/color.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/lang/reader.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/lang/reader.rkt</a> </p>
<p>这个插件根据游戏语言的语法(而不是 Racket 的默认规则)给程序着色，用红色突出显示词法语法错误。</p>
<h3>更多的语言</h3>
<p>Racket 分发的源代码包括几十条独特的 <font face="Courier New">#lang</font> 行。最常见的是 <font face="Courier New">#lang racket/base</font> ，这是 <font face="Courier New">#lang racket</font> 的变体。其他常见的行号包括： <font face="Courier New">#lang scribble/manual</font> 用于文档源代码， <font face="Courier New">#lang racket/unit</font> 用于外部可链接的组件， <font face="Courier New">#lang scheme</font> 用于遗留模块， <font face="Courier New">#lang setup/infotab</font> 用于库元数据。大多数 Racket 语言都使用S表达式表示法，但 <font face="Courier New">scribble/manual</font> 是一个明显的例外；即使是喜欢括号的 Racket 爱好者也承认，S表达式对于文档来说是一种糟糕的符号。</p>
<p>不同的 Racket 语言由于不同的原因而存在，它们在不同程度上使用 Racket 的语言创造工具。开发人员创造新语言并不容易，但使用一门新语言的好处有时会超过学习一种语言变体的成本。这些好处对于 Racket 使用者和 Racket 核心开发者来说都是唾手可得的。</p>
<p>Racket 对S表达式语言和语言扩展的支持非常丰富，而本文中的示例仅涉及该工具箱的表面。Racket 的非S表达式语法工具箱仍在发展，尤其是在可组合解析器和语言触发 IDE 插件方面。幸运的是，Racket 的 <font face="Courier New">#lang</font> 协议将剩余的大部分工作从核心系统转移到库中。这意味着 Racket 用户和 Racket 核心开发者一样有能力开发改进的语法工具。</p>
</div>
</body></html>