<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0043)https://queue.acm.org/detail.cfm?id=2068896 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<body>
<div class="container">
<h1 class="hidetitle">Creating Languages in Racket</h1>
<h2>Sometimes you just have to make a better mousetrap.</h2>
<br>
<h3> Matthew Flatt, University of Utah </h3>
<br>
<p>Choosing the right tool for a simple job is easy: a screwdriver is usually the best option when you need to change the battery in a toy, and grep is the obvious choice to check for a word in a text document. For more complex tasks, the choice of tool is rarely so straightforward—all the more so for a programming task, where programmers have an unparalleled ability to construct their own tools. Programmers frequently solve programming problems by creating new tool programs, such as scripts that generate source code from tables of data.</p>
<p>Since programmers often build task-specific tools, one way to make them more productive is to give them better tool-making tools. When tools take the form of program generators, this idea leads to libraries for creating languages that are directly extensible. Programmers may even be encouraged to think about a problem in terms of a language that would better support the task. This approach is sometimes called <i>language-oriented programming</i>.<sup>1</sup></p>
<p>Racket is both a programming language and a framework for building programming languages. A Racket program can contain definitions that extend the syntax of the language for use later in the same program, and language extensions can be packaged as modules for use in multiple programs. Racket supports a smooth path from relatively simple language extensions to completely new languages, since a programming tool, like any other piece of software, is likely to start simple and grow as demands on the language increase.</p>
<p>As an example task, consider the implementation of a text-adventure game (also known as interactive fiction), where a player types commands to move around in a virtual world and interact with objects:</p>
<p style="font-family:monospace;font-size:1.1em;"> <br>You're standing in a meadow. <br>There is a house to the north. <br>&gt; north <br>You are standing in front of a house. <br>There is a door here. <br>&gt; open door <br>The door is locked. <br>&gt; <br></p>
<p>To make the game interesting, a programmer must populate the virtual world with places and things that have rich behavior. Most any programming language could implement this virtual world, but choosing the right language construct (i.e., the right tool) to represent each game element is a crucial step in the development process.</p>
<p>The right constructs allow commands, places, and things to be created easily—avoiding error-prone boilerplate code to set up the world's state and connections—while also allowing the use of a programming language's full power to implement behaviors.</p>
<p>In a general-purpose programming language, no built-in language construct is likely to be a perfect fit. For example, places and things could be objects, while commands could be implemented as methods. The game's players, however, don't call methods but instead type commands that have to be parsed and dynamically mapped to responses for places and things. Similarly, saving and loading a game requires inspecting and restoring the state of places and things, which is partly a matter of object serialization but also of setting variables to unmarshaled values (or else using an indirection through a dictionary for each reference from one object to another).</p>
<p>Some programming languages include constructs—such as overloading or laziness—that a clever programmer can exploit to encode a domain-specific language. The design of Racket addresses the problem more directly; it gives programmers tools to explicitly extend the programming language with new syntax. Some tasks require only a small extension to the core language, while others benefit from the creation of an entirely new language. Racket supports both ends of the spectrum, and it does so in a way that allows a smooth progression from one end to the other. As a programmer's needs or ambitions grow for a particular task, the programmer can take advantage of ever more of Racket's unified framework for language extension and construction.</p>
<p>The text-adventure example presented here illustrates the progression from a simple embedding in Racket to a separate domain-specific language (including IDE support for syntax coloring), explaining relevant Racket details along the way; no prior knowledge of Racket is necessary. Readers who prefer a more complete introduction to the language should consult The Racket Guide.<sup>2</sup></p>
<p>The example is a "toy" in multiple senses of the world, but it is also a scale model of industry practice. Most every video-game developer uses a custom language, including the Racket-based language that is used to implement content for the <i> Uncharted</i> video-game series.<sup>3</sup> Evidently, when billions of entertainment dollars are on the line, the choice of programming language matters—even to the point of creating new, special-purpose languages.</p>
<h3>The World in Plain Racket</h3>
<p>Our text adventure game contains a fixed set of <i>places</i>, such as a meadow, house, or desert, and a fixed set of <i>things</i>, such as a door, key, or flower. The player navigates the world and interacts with things using commands that are parsed as either one or two words: a single verb (i.e., an intransitive verb, since it does not have a target object), such as <i>help</i> or <i> look</i>; or a verb followed by the name of a thing (i.e., a transitive verb followed by a noun), such as <i>open door</i> or <i>get key</i>. Navigation words such as <i>north</i> or <i>in</i> are treated as verbs. A user can save the game using the <i>save</i> and <i>load</i> verbs, which work everywhere and prompt the user for a file name.</p>
<p>To implement a text-adventure game in Racket, you would start by declaring structure types for each of the three game elements:</p>
<p style="font-family:monospace;font-size:1.1em;"> <br><font color="#853D24">(</font>struct <font color="#262680">verb</font> <br> <font color="#853D24">(</font><font color="#262680">aliases</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#C2731F">; &nbsp;list of symbols</font> <br> &nbsp;<font color="#262680">Desc</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#C2731F">; &nbsp;string</font> <br> &nbsp;<font color="#262680">transitive?</font><font color="#853D24">)) &nbsp; &nbsp; &nbsp;</font><font color="#C2731F">; &nbsp;Boolean</font> <br> <br><font color="#853D24">(</font>struct <font color="#262680">thing</font> <br> <font color="#853D24">(</font><font color="#262680">name</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#C2731F">; &nbsp;symbol</font> <br> &nbsp;<font color="#853D24">[</font><font color="#262680">state</font><font color="#853D24"> #:mutable] &nbsp;</font><font color="#C2731F">; &nbsp;any value</font> <br> &nbsp;<font color="#262680">actions</font><font color="#853D24">))</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#C2731F">; &nbsp;list of verb-function &nbsp;pairs</font> <br> <br><font color="#853D24">(</font>struct <font color="#262680">place</font> <br> <font color="#853D24">(</font><font color="#262680">desc</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#C2731F">; &nbsp;string</font> <br> &nbsp;<font color="#853D24">[</font><font color="#262680">things</font><font color="#853D24"> #:mutable] </font><font color="#C2731F">; &nbsp;list of things</font> <br> &nbsp;<font color="#262680">actions</font><font color="#853D24">))</font> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#C2731F">; &nbsp;list of verb-function &nbsp;pairs</font> <br></p>
<p>Racket is a dialect of Lisp and a descendant of Scheme, so its syntax uses parentheses and a liberal grammar of identifiers (e.g., <font face="Courier New">transitive?</font> is an identifier). A semicolon introduces a newline-terminated comment. Square brackets are interchangeable with parentheses but are used by convention in certain contexts, such as grouping a field name with modifiers. The <font face="Courier New">#:mutable</font> modifier declares a field as mutable, since fields are immutable by default.</p>
<p>The first <font face="Courier New">struct</font> form in the code binds verb to function, taking one argument for each field and creating a verb instance. For example, you can define a <font face="Courier New">south</font> verb with alias <font face="Courier New">s</font> as</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define <font color="#262680">south</font> <font color="#853D24">(</font><font color="#262680">verb</font> <font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#218C21">'south 's</font><font color="#853D24">)</font> <font color="#218C21">"go south" #false</font><font color="#853D24">))</font> </p>
<p>Lisp and Racket programs tend to use strings for the text that is to be shown to an end user—for example, verb descriptions such as <font face="Courier New">"go south".</font> A <i>symbol</i>, written with a leading single quote (e.g., <font face="Courier New">'south), </font>is more typically used for an internal name, such as a verb alias.</p>
<p>Given the definition of <font face="Courier New">south</font> and a thing, <font face="Courier New">flower</font>, you could define a <font face="Courier New">meadow</font> place where the <font face="Courier New">south</font> verb moves the player to a <font face="Courier New">desert</font> place:</p>
<p style="font-family:monospace;font-size:1.1em;"> <br><font color="#853D24">(</font>define <font color="#262680">meadow</font> <font color="#853D24">(</font><font color="#262680">place</font> <font color="#218C21">"You're &nbsp;in a meadow."</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#262680">flower</font><font color="#853D24">)</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#853D24">(</font><font color="#0000FF">cons</font> <font color="#262680">south</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font>lambda <font color="#853D24">()</font> <font color="#262680">desert</font><font color="#853D24">)))))</font> <br></p>
<p>The <font face="Courier New">list</font> function creates a list, while <font face="Courier New">cons</font> pairs two values. The <font face="Courier New">cons</font> function usually pairs an element with a list to form a new list, but here <font face="Courier New">cons</font> is used to pair a verb with a function that implements the verb's response. The lambda form creates an anonymous function, which in this case expects zero arguments.</p>
<p>When a verb's response function produces a place, such as <font face="Courier New">desert</font> in the example, the game execution engine will move the player to the returned place. The game engine's support for saving and loading game state, meanwhile, requires a mapping between places and their names. (Places can be implemented as objects that can be serialized, but restoring a game requires both deserialization and updating Racket-level variables such as <font face="Courier New">meadow</font>.) The <font face="Courier New">record-element!</font> function implements mappings between names and places:</p>
<p style="font-family:monospace;font-size:1.1em;"> <br><font color="#853D24">(</font>define <font color="#262680">names</font> <font color="#853D24">(</font><font color="#0000FF">make-hash</font><font color="#853D24">))</font> &nbsp; &nbsp;<font color="#C2731F">; symbol to place/thing</font> <br><font color="#853D24">(</font>define <font color="#262680">elements</font> <font color="#853D24">(</font><font color="#0000FF">make-hash</font><font color="#853D24">))</font> <font color="#C2731F">; &nbsp;place/thing to symbol</font> <br> <br><font color="#853D24">(</font>define <font color="#853D24">(</font><font color="#262680">record-element! name val</font><font color="#853D24">)</font> <br> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-set!</font> <font color="#262680">names name val</font><font color="#853D24">)</font> <br> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-set!</font> <font color="#262680">elements val name</font><font color="#853D24">))</font> <br> <br><font color="#853D24">(</font>define <font color="#853D24">(</font><font color="#262680">name-&gt;element name</font><font color="#853D24">)</font> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-ref</font> <font color="#262680">names name</font><font color="#853D24">))</font> <br><font color="#853D24">(</font>define <font color="#853D24">(</font><font color="#262680">element-&gt;name obj</font><font color="#853D24">)</font> &nbsp;<font color="#853D24">(</font><font color="#0000FF">hash-ref</font> <font color="#262680">elements obj</font><font color="#853D24">))</font> <br></p>
<p>Consequently, the complete implementation of the meadow is:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define <font color="#262680">meadow</font> <font color="#853D24">(</font><font color="#262680">place ....</font><font color="#853D24">)</font><font color="#853D24">)</font> <font color="#C2731F">; as above</font> <br><font color="#853D24">(</font><font color="#262680">record-element!</font> <font color="#218C21">'meadow</font> <font color="#262680">meadow</font><font color="#853D24">)</font> </p>
<p>Things must be defined and registered in much the same way as places. Verbs must be collected into a list to be used by the game's command parser. Finally, the parsing and execution engine needs a set of verbs that work everywhere, each with its response function. All of those pieces form the interesting part of the game implementation, while the parsing and execution engine is a few dozen lines of static infrastructure.</p>
<p>The complete game implementation is available online:<br></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/0-longhand/txtadv+world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/0-longhand/txtadv+world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/0-longhand/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/0-longhand/README.txt</a> <br> </p>
<p>Note that the code needed to construct the virtual world is particularly verbose.</p>
<h3>Syntactic Abstraction</h3>
<p>Although the data-representation choices of the previous section are typical for a Racket program, a Racket programmer is unlikely to write the repetitive code that directly defines and registers places, since it includes so many boilerplate <font face="Courier New">list</font>s, <font face="Courier New">cons</font>es, and <font face="Courier New">lambda</font>s. Instead, a Racket programmer would write</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-place meadow</font> <br> &nbsp; <font color="#218C21">"You're in a meadow." </font> <br> &nbsp; <font color="#853D24">[</font><font color="#262680">flower</font><font color="#853D24">]</font> <br> &nbsp; <font color="#853D24"> ([</font><font color="#262680">south desert</font><font color="#853D24">]))</font> </p>
<p>and would add a <font face="Courier New">define-place</font> form to Racket using a pattern-based macro. The simplest form of such a macro uses <font face="Courier New">define-syntax-rule</font>: <br></p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id desc</i></font><font color="#853D24"> [</font><font color="#262680"><i>thng</i></font><font color="#853D24">] ([</font><font color="#262680"><i>vrb &nbsp;expr</i></font><font color="#853D24">]))</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp;(</font>define <font color="#262680"><i>id </i></font><font color="#853D24">(</font><font color="#262680">place <i> desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list </font><font color="#262680"><i>thng</i></font><font color="#853D24"> )</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list </font><font color="#853D24">(</font><font color="#0000FF">cons </font><font color="#262680"><i>vrb </i></font><font color="#853D24">(</font>lambda <font color="#853D24">() </font><font color="#262680"><i>expr</i></font><font color="#853D24"> )))))</font> <br><font color="#853D24"> &nbsp; &nbsp;(</font><font color="#262680">record-element! </font><font color="#218C21">'</font><font color="#262680"><i>id &nbsp;id</i></font><font color="#853D24"> )))</font> <br></p>
<p>The form immediately after <font face="Courier New">define-syntax-rule</font> is a <i>pattern</i>, and the form after the pattern is a <i>template</i>. A use of a macro that matches its pattern is replaced by the macro's template, modulo substitutions of <i>pattern variables</i> for their matches. The <font face="Courier New"><i>id</i></font><i>, </i><font face="Courier New"><i>desc</i></font><i>, </i><font face="Courier New"><i>thng</i></font><i>, </i><font face="Courier New"><i>vrb</i></font>, and <font face="Courier New"><i>expr</i></font> identifiers in this pattern are pattern variables.</p>
<p>Note that the <font face="Courier New">define-place</font> form cannot be a function. The <font face="Courier New">desert</font> expression after <font face="Courier New">south</font> is, in general, an expression whose evaluation must be delayed until the <font face="Courier New">south</font> command is entered. More significantly, the form should bind the variable <font face="Courier New">meadow</font> so that Racket expressions for commands can refer to the place directly. In addition, the variable's source name (as opposed to its value) is used to register the place in the table of elements.</p>
<p>The <font face="Courier New">define-place</font> macro so far matches exactly one thing in a place and exactly one verb and response expression. To generalize to any number of things, verbs, and expressions, you add ellipses to the pattern:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [</font><font color="#262680"><i>thng</i></font> ...<font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([</font><font color="#262680"><i>vrb expr</i></font><font color="#853D24"> ] &nbsp;</font>...<font color="#853D24">))</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680">id</font><font color="#853D24"> &nbsp;(</font><font color="#262680">place</font> <font color="#262680"><i>desc</i></font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#853D24">(</font><font color="#0000FF">list</font> <font color="#262680"><i>thng</i></font> &nbsp;...<font color="#853D24">)</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<font color="#853D24">(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#0000FF">cons</font> <font color="#262680"><i>vrb</i></font><font color="#853D24"> (</font>lambda<font color="#853D24"> () </font><font color="#262680"><i>expr</i></font><font color="#853D24"> ))</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<font color="#853D24">)))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-element!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> </p>
<p>Ellipses work in the obvious way, and with this generalized <font face="Courier New">define-place</font>, you can put both a cactus and a key initially in the desert and respond to direction verbs other than <font face="Courier New">north</font> by staying in the desert:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-place desert <br> &nbsp;<font color="#218C21">"You're in a desert."</font> <br> &nbsp;<font color="#853D24">[</font>cactus key<font color="#853D24">]</font> <br> &nbsp;<font color="#853D24">([</font>north meadow<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">[</font>south desert<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">[</font>east desert<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">[</font>west desert<font color="#853D24">]))</font> </p>
<p>The macro for a thing is similarly straightforward:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-thing</font> <font color="#262680"><i>id</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [</font><font color="#262680"><i>vrb expr</i></font><font color="#853D24"> ] &nbsp;</font>...<font color="#853D24">)</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680">id</font> <br> &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font><font color="#262680">thing </font><font color="#218C21">'id #false </font><font color="#853D24">(</font><font color="#0000FF">list </font><font color="#853D24">(</font><font color="#0000FF">cons </font><font color="#262680"><i>vrb</i> </font><font color="#853D24">(</font>lambda <font color="#853D24">() </font><font color="#262680"><i>expr</i></font><font color="#853D24"> )) </font>...<font color="#853D24">)))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-thing!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> <br></p>
<p>Verbs are slightly trickier, because you want to make simple verbs especially compact to specify, and you need one kind of pattern for intransitive verbs and another for transitive verbs. The following example illustrates the target syntax:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-verbs all-verbs</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">quit</font><font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">north</font><font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> n<font color="#853D24">) </font><font color="#218C21">"go &nbsp;north"</font><font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">knock</font> _<font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">get</font> _<font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> grab &nbsp;take<font color="#853D24">) </font><font color="#218C21">"take"</font><font color="#853D24">])</font> <br></p>
<p>This example defines four verbs: <font face="Courier New">quit</font> as an intransitive verb with no aliases; <font face="Courier New">north</font> as an intransitive verb with alias <font face="Courier New">n</font> and a preferred description <font face="Courier New">go north</font>; <font face="Courier New">knock</font> as a transitive verb (as indicated by the underscore) with no aliases; and <font face="Courier New">get</font> as a transitive verb with aliases <font face="Courier New">grab</font> and <font face="Courier New">take</font> and preferred description <font face="Courier New">take</font>. Finally, all of these verbs are collected into a list that is bound to <font face="Courier New">all-verbs</font> for use by the game's command parser.</p>
<p>Implementing the <font face="Courier New">define-verbs</font> form requires a more general kind of pattern matching to support different shapes of verb specifications and to match <font face="Courier New">=</font> and <font face="Courier New">_</font> as literals. An implementation of <font face="Courier New">define-verbs can </font>defer the work of handling an individual verb to a <font face="Courier New">define-one-verb</font> macro, which uses <font face="Courier New">define-syntax</font> and <font face="Courier New">syntax-rules</font>:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax <font color="#262680">define-one-verb</font> <br><font color="#853D24"> &nbsp;(</font>syntax-rules<font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> _<font color="#853D24">)</font> <br> &nbsp; &nbsp;<font color="#853D24">[(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font><font color="#853D24"> (</font><font color="#0000FF">=</font> <font color="#262680"><i>alias</i></font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> &nbsp;(</font><font color="#262680">verb</font><font color="#853D24"> (</font><font color="#0000FF">list</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font> <font color="#218C21">'alias</font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font> <font color="#218C21">#false</font><font color="#853D24">))] &nbsp; &nbsp; </font> <br><font color="#853D24"> &nbsp; &nbsp; [(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font> _<font color="#853D24"> (</font><font color="#0000FF">=</font> <font color="#262680"><i>alias</i></font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> &nbsp;(</font><font color="#262680">verb</font><font color="#853D24"> (</font><font color="#0000FF">list</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font> <font color="#218C21">'alias</font> ...<font color="#853D24">) </font><font color="#262680"><i>desc</i></font> <font color="#218C21">#true</font><font color="#853D24">))] &nbsp; </font> <br><font color="#853D24"> &nbsp; &nbsp; [(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font><font color="#853D24">)</font> <br> &nbsp; &nbsp; <font color="#853D24"> &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> (</font><font color="#262680">verb</font><font color="#853D24"> (</font><font color="#0000FF">list</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;) (</font><font color="#0000FF">symbol-&gt;string</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;) </font><font color="#218C21">#false</font><font color="#853D24">))]</font> <br><font color="#853D24"> &nbsp; &nbsp; [(</font><font color="#262680">one-verb</font> <font color="#262680"><i>id</i></font> _<font color="#853D24">)</font> <br> &nbsp; &nbsp; <font color="#853D24"> &nbsp;(</font>define <font color="#262680">id</font><font color="#853D24"> (</font><font color="#262680">verb </font><font color="#853D24">(</font><font color="#0000FF">list </font><font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> ) (</font><font color="#0000FF">symbol-&gt;string</font> <font color="#218C21">'</font><font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;) </font><font color="#218C21">#true</font><font color="#853D24">))]))</font> <br></p>
<p>The <font face="Courier New">=</font> and <font face="Courier New">_</font> in parentheses after <font face="Courier New">syntax-rules</font> indicate that <font face="Courier New">=</font> and <font face="Courier New">_</font> are literals, rather than pattern variables, in the patterns that follow. Each pattern afterward has a corresponding template. Thus, in</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-verbs all-verbs</font> <br><font color="#262680"> &nbsp; ....</font> <br><font color="#853D24"> &nbsp; [</font><font color="#262680">get</font> _<font color="#853D24"> &nbsp;(</font><font color="#0000FF">=</font> grab take<font color="#853D24">) </font><font color="#218C21">"take"</font><font color="#853D24">])</font> <br></p>
<p>the <font face="Courier New">define-verbs</font> expansion turns the last clause into a <font face="Courier New">define-one-verb</font> use:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font><font color="#262680">define-one-verb get</font> _<font color="#853D24"> (</font><font color="#0000FF">=</font> <font color="#262680">grab take</font><font color="#853D24">) </font><font color="#218C21">"take"</font><font color="#853D24">)</font> </p>
<p>This matches the first pattern of <font face="Courier New">one-verb</font> and expands into:</p>
<p style="font-family:monospace;font-size:1.1em;"> (define <font color="#262680">get</font> (<font color="#262680">verb</font> (<font color="#0000FF">list</font> <font color="#218C21">'get 'grab 'take</font>) <font color="#218C21">"take" #true</font>))</p>
<p>Finally, a <font face="Courier New">define-everywhere</font> form is created for defining verb responses that work throughout the world, as needed for verbs such as <font face="Courier New">save</font> and <font face="Courier New">load</font>:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-everywhere</font> <font color="#262680"><i>id</i></font><font color="#853D24"> ([</font><font color="#262680"><i>vrb &nbsp;expr</i></font><font color="#853D24"> ] </font>...<font color="#853D24">)) &nbsp; </font> <br><font color="#853D24"> &nbsp; (</font>define <font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#0000FF">cons</font> <font color="#262680"><i>vrb</i></font><font color="#853D24"> (</font>lambda<font color="#853D24"> () </font><font color="#262680"><i>expr</i></font><font color="#853D24"> )) </font>...<font color="#853D24">)))</font> <br> <br><font color="#853D24">(</font><font color="#262680">define-everywhere &nbsp;everywhere-actions</font> <br><font color="#853D24"> &nbsp; ([</font><font color="#262680">quit</font><font color="#853D24"> &nbsp;(</font>begin<font color="#853D24"> &nbsp;(</font><font color="#0000FF">printf</font> <font color="#218C21">"Bye!\n"</font><font color="#853D24">) (</font><font color="#0000FF">exit</font><font color="#853D24">))]</font> <br><font color="#853D24"> &nbsp;&nbsp; [</font><font color="#262680">save</font><font color="#853D24"> &nbsp;(</font><font color="#262680">save-game</font><font color="#853D24">)]</font> <br><font color="#853D24"> &nbsp;&nbsp; [</font><font color="#262680">load</font><font color="#853D24"> &nbsp;(</font><font color="#262680">load-game</font><font color="#853D24">)]</font> <br><font color="#262680"> &nbsp;&nbsp; ....</font><font color="#853D24">))</font> <br></p>
<p>The <font face="Courier New">define-place</font>, <font face="Courier New">define-thing</font>, and <font face="Courier New">define-verb</font> macros are examples of <i>syntactic abstraction</i>. They abstract over repeated patterns of syntax, so that a programmer can avoid boilerplate code and concentrate on the creation of interesting verbs, places, and things.</p>
<p> The revised game implementation, which has a compact and readable implementation of the virtual world, is available online: </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/1-monolith/txtadv+world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/1-monolith/txtadv+world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/1-monolith/" target="_blank">http://queue.acm.org/downloads/2011/racket/1-monolith/</a>README.txt <br> </p>
<h3>Syntactic Extension</h3>
<p>A Racket programmer who is interested in writing a single text-adventure game would likely stop extending the language at this point. If the text-adventure engine should be reusable for multiple worlds, however, a Racket programmer is likely to take a step beyond syntactic abstraction to <i>syntactic extension</i>.</p>
<p>The difference between abstraction and extension is partly in the eye of the beholder, but extension suggests that functions such as <font face="Courier New">place</font> and <font face="Courier New">record-element!</font> can be kept private, while <font face="Courier New">define-place</font> is exported for use in the world-defining module with implementation-independent semantics. In the world-defining module, macros such as <font face="Courier New">define-place</font> have the same status as built-in forms such as <font face="Courier New">define</font> and <font face="Courier New">lambda</font>.</p>
<p>To make this shift, you can put the <font face="Courier New">define-verbs</font>, <font face="Courier New">define-place</font>, <font face="Courier New">define-thing</font>, and <font face="Courier New">define-everywhere</font> definitions in their own module, called world.rkt.</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">racket</font> <br><font color="#853D24">(</font>require <font color="#218C21">"txtadv.rkt"</font><font color="#853D24">)</font> <br> <br><font color="#853D24">(</font><font color="#262680">define-verbs ....</font><font color="#853D24">)</font> <br><font color="#853D24">(</font><font color="#262680">define-everywhere ....</font><font color="#853D24">)</font> <br><font color="#853D24">(</font><font color="#262680">define-thing ....</font><font color="#853D24">) </font>... <br><font color="#853D24">(</font><font color="#262680">define-place ....</font><font color="#853D24">) </font>... <br></p>
<p>This module imports txtadv.rkt, which exports <font face="Courier New">define-verbs</font>, etc., as well as functions used in verb responses such as <font face="Courier New">save-game</font> and <font face="Courier New">load-game</font>. Meanwhile, txtadv.rkt keeps private the structures and other functions that implement the world data types.</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">racket</font> <br><font color="#853D24">(</font>provide <font color="#262680">define-verbs &nbsp;define-thing</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">define-place define-everywhere</font> <br> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">save-game</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">load-game</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#262680">....</font><font color="#853D24">)</font> <br> <br><font color="#853D24">(</font>struct <font color="#262680">verb &nbsp;....</font><font color="#853D24">)</font> <br><font color="#262680">....</font> <br><font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-verbs &nbsp;....</font><font color="#853D24">) </font><font color="#262680">....</font><font color="#853D24">)</font> <br><font color="#262680">....</font> <br></p>
<p>The <font face="Courier New">#lang racket</font> line that starts each module indicates that the module is implemented in the <font face="Courier New">racket</font> language. In world.rkt, <font face="Courier New">require</font> additionally imports both the syntactic extensions and functions that are exported by the txtadv.rkt module.</p>
<p>Since macro binding is part of the Racket language, as opposed to being implemented as a separate preprocessor, macro bindings can work with module imports and exports in the same way as variable bindings. In particular, the definition of the <font face="Courier New">define-verbs</font> macro can see the <font face="Courier New">verb</font> constructor function because of the rules of lexical scope, while code in the world.rkt module cannot access <font face="Courier New">verb</font> directly because of the same scoping rules. Since a use of <font face="Courier New">define-verbs</font> in world.rkt expands to a use of <font face="Courier New">verb</font>, considerable language machinery is required for Racket to maintain lexical scope in the presence of macro expansion, but the result is that syntactic extension is easy for programmers.</p>
<p>The modular game implementation is available online:</p>
<p><a href="https://queue.acm.org/downloads/2011/racket/2-modules/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/2-modules/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/2-modules/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/2-modules/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/2-modules/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/2-modules/README.txt</a> <br> </p>
<h3>Module Languages</h3>
<p>Although the world.rkt module cannot directly access constructor functions such as <font face="Courier New">verb</font>, the module still has access to all of the Racket language and, via <font face="Courier New">require</font>, any other module's exports. More constraints on world.rkt may be appropriate to ensure that assumptions of txtadv.rkt are satisfied.</p>
<p>To exert further control, you can convert txtadv.rkt from a module that exports a language extension to one that exports a language. Then, instead of starting with <font face="Courier New">#lang racket</font>, world.rkt starts with</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">s-exp</font> <font color="#218C21">"txtadv.rkt"</font></p>
<p>For now, <font face="Courier New">s-exp</font> indicates that the language of world.rkt uses S-expression notation (i.e., parentheses), while txtadv.rkt defines syntactic forms. Later, the S-expression and syntactic-form specifications are combined into a single name, analogous to <font face="Courier New">#lang racket</font>.</p>
<p>Along with changing world.rkt, you can change txtadv.rkt to export everything from racket:</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">racket</font> <br><font color="#853D24">(</font>provide <font color="#262680">define-verbs &nbsp;....</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; <font color="#853D24">(</font>all-from-out <font color="#262680">racket</font><font color="#853D24">))</font> <br><font color="#262680">....</font> </p>
<p>Instead of <font face="Courier New">(all-from-out racket)</font>, you could use <font face="Courier New">(except-out (all-from-out racket) require)</font> to withhold the <font face="Courier New">require</font> form from world.rkt. Alternatively, instead of using <font face="Courier New">all-from-out</font> and then naming bindings to withhold, you could explicitly export only certain pieces from racket.</p>
<p>The exports of txtadv.rkt completely determine the bindings that are available in world.rkt—not only the functions, but also syntactic forms such as <font face="Courier New">require</font> or <font face="Courier New">lambda</font>. For example, txtadv.rkt could supply a <font face="Courier New">lambda</font> binding to world.rkt that implements a different kind of function than the usual <font face="Courier New">lambda</font>, such as functions with lazy evaluation.</p>
<p>More commonly, a module language can replace the <font face="Courier New">#%module-begin</font> form that implicitly wraps the body of a module. Specifically, txtadv.rkt can provide an alternate <font face="Courier New">#%module-body</font> that forces world.rkt to have a single <font face="Courier New">define-verbs</font> form, a single <font face="Courier New">define-everywhere</font> form, a sequence of <font face="Courier New">define-thing</font> declarations, and a sequence of <font face="Courier New">define-place</font> declarations; if world.rkt has any other form, it can be rejected as a syntax error. Such constraints can enforce restrictions to limit the power of the txtadv.rkt language, but they can also be used to provide domain-specific checking and error messages.</p>
<p>The game implemented with a txtadv.rkt language is available online: </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/3-module-lang/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/3-module-lang/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/3-module-lang/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/3-module-lang/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/3-module-lang/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/3-module-lang/README.txt</a> <br> </p>
<p>The <font face="Courier New">#%module-begin</font> replacement in the implementation requires <font face="Courier New">define-verbs</font> followed by <font face="Courier New">define-everywhere</font>, then allows any number of other declarations. The module must end with a place expression, which is used as the starting location for the game.</p>
<h3>Static Checks</h3>
<p>The <font face="Courier New">define-verb</font>, <font face="Courier New">define-place</font>, and <font face="Courier New">define-thing</font> forms bind names in the same way as any other Racket definition, and each reference to a verb, place, or thing is a Racket-level reference to the defined name. This approach makes it easy for <font face="Courier New">verb-response</font> expressions, which are implemented in Racket, to refer to other things and places in the virtual world. It also means, however, that misusing a reference as a thing can lead to a runtime error. For example, the incorrect reference to <font face="Courier New">desert</font> as a thing in</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-place room <br> &nbsp; <font color="#218C21">"You're in the house." </font> <br> &nbsp; <font color="#853D24">[</font>trophy desert<font color="#853D24">]</font> <br> &nbsp; <font color="#853D24">([</font>out house-front<font color="#853D24">]))</font> <br></p>
<p>triggers a failure only when the player enters <font face="Courier New">room,</font> and the game engine fails when trying to print the things within the place.</p>
<p>Many languages provide type checking or other static types to ensure the absence of certain runtime errors. Racket macros can implement languages with static checks, and macros can even implement language extensions that perform static checks within a base language that defers similar checks to runtime. Specifically, you can adjust <font face="Courier New">define-verb</font>, <font face="Courier New">define-place</font>, and <font face="Courier New">define-thing</font> to check certain references, such as requiring that the list of initial things in a place contain only names that are defined as things. Similarly, names used as verbs with responses can be checked to ensure that they are declared as verbs, suitably transitive or intransitive.</p>
<p>Implementing static checks typically requires macros that are more expressive than pattern-matching macros. In Racket, arbitrary compile-time code can perform the role of expander for a syntactic form, because the most general form of a macro definition is</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax <font color="#262680">id <i> transformer-expr</i></font><font color="#853D24"> )</font></p>
<p>where <font face="Courier New">transformer-expr</font> is a compile-time expression that produces a function. The function must accept one argument, which is a representation of a use of the <font face="Courier New">id</font> syntactic form, and the function must produce a representation of the use's expansion. In the same way that <font face="Courier New">define-syntax-rule</font> is shorthand for <font face="Courier New">define-syntax</font> plus <font face="Courier New">syntax-rules</font> and a single pattern, <font face="Courier New">syntax-rules</font> is shorthand for a function of one argument that pulls apart expressions of a certain shape (matching a pattern) and constructs a new expression for the result (based on a template).</p>
<p>The compile-time language that is used for <font face="Courier New"><i>transformer-expr</i></font> can be different from the surrounding runtime language, but <font face="Courier New">#lang racket</font> seeds the language of compile-time expressions with essentially the same language as for runtime expressions. New bindings can be introduced to the compile-time phase with <font face="Courier New">(require (for-syntax ....))</font> instead of just <font face="Courier New">require</font>, and local bindings can be added to the compile-time phase through definitions wrapped with <font face="Courier New">begin-for-syntax</font>.</p>
<p>For example, to check for verbs, things, and places statically, <font face="Courier New">begin-for-syntax</font> can define a new typed structure:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>begin-for-syntax <br><font color="#853D24"> &nbsp;(</font>struct <font color="#262680">typed</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">id</font> &nbsp; &nbsp; <font color="#C2731F">; an identifier</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp;</font><font color="#262680">type</font><font color="#853D24">)</font>&nbsp; <font color="#C2731F">; &nbsp;a string</font> <br><font color="#853D24"> &nbsp; &nbsp; #:property </font><font color="#0000FF">prop:procedure </font><font color="#853D24">(</font>lambda <font color="#853D24">(</font><font color="#262680">self stx</font><font color="#853D24">) (</font><font color="#262680">typed-id self</font><font color="#853D24">))))</font> </p>
<p>An <font face="Courier New"><i>identifier</i></font> is written as a symbol, but with a <font face="Courier New">#</font> prefix, so that</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>typed #'gen-desert <font color="#218C21">"place"</font><font color="#853D24">)</font></p>
<p>associates the binding <font face="Courier New">gen-desert</font> to the type <font face="Courier New">"place"</font>. The <font face="Courier New">#:property prop:procedure</font> clause in the declaration of <font face="Courier New">typed</font> makes a typed instance act as a function (for reasons explained later). The function takes one argument in addition to the implicit <font face="Courier New">self</font> argument, but it ignores the argument and returns the <font face="Courier New">typed</font> instance's <font face="Courier New">id</font>.</p>
<p>You can use <font face="Courier New">typed</font> by changing the <font face="Courier New">define-place</font> form to bind a place name <font face="Courier New"><i>id</i></font> to a compile-time <font face="Courier New">typed</font> record. At the same time, <font face="Courier New">define-place</font> binds a generated name <font face="Courier New"><i>gen-id</i></font> to the runtime place record:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id</i></font> <font color="#262680">....</font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp;(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680"><i>gen-id</i></font><font color="#853D24"> (</font><font color="#262680">place &nbsp;....</font><font color="#853D24">)) </font><font color="#C2731F">; as before</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font>define-syntax <font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;(</font><font color="#262680">typed</font> #'<font color="#262680"><i>gen-id</i></font> <font color="#218C21">"place"</font><font color="#853D24">))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-element!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> <br></p>
<p>Since a <font face="Courier New">typed</font> record acts as a function, a use of <font face="Courier New"><i>id</i></font> expands to <font face="Courier New"><i>gen-id</i></font> , so <font face="Courier New"><i>id</i></font> still can be used as a direct reference to the <font face="Courier New">place</font>. At the same time, other macros can look at the <font face="Courier New"><i>id</i></font> binding and determine that its expansion will have the type <font face="Courier New">"place"</font>. <br></p>
<p>Other macros inspect types by using a <font face="Courier New">check-type macro</font>. The implementation of <font face="Courier New">check-type</font> is in the complete code online, but its essential feature is that it uses a compile-time function <font face="Courier New">syntax-local-value</font> to obtain the compile-time value of an identifier; the <font face="Courier New">check-type</font> macro then uses <font face="Courier New">typed?</font> to check whether the compile-time value is a type declaration, in which case it uses <font face="Courier New">typed-type</font> to check whether the declared type is the expected one. As long as the type check passes, <font face="Courier New">check-type</font> expands to its first argument.</p>
<p>The <font face="Courier New">define-place</font> macro uses <font face="Courier New">check-typed</font> to check whether the list of things at the <font face="Courier New">place</font> contains only names that are defined as things. The <font face="Courier New">define-place</font> macro also uses <font face="Courier New">check-typed</font> to check whether verbs that have responses in the <font face="Courier New">place</font> are defined as intransitive verbs:</p>
<p style="font-family:monospace;font-size:1.1em;"> <font color="#853D24">(</font>define-syntax-rule<font color="#853D24"> (</font><font color="#262680">define-place</font> <font color="#262680"><i>id</i></font> <br><font color="#262680"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i> desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [</font><font color="#262680"><i>thng</i></font> &nbsp;...<font color="#853D24">]</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([</font><font color="#262680"><i>vrb expr</i></font><font color="#853D24"> ] &nbsp;</font>...<font color="#853D24">))</font> <br> &nbsp;<font color="#853D24">(</font>begin <br><font color="#853D24"> &nbsp; &nbsp; (</font>define <font color="#262680"><i>gen-id</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; (</font><font color="#262680">place</font> <font color="#262680"><i>desc</i></font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#262680">check-type</font> <font color="#262680"><i>thng</i></font> <font color="#218C21">"thing"</font><font color="#853D24">) &nbsp;</font>...<font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</font><font color="#0000FF">list</font><font color="#853D24"> (</font><font color="#0000FF">cons</font><font color="#853D24"> (</font><font color="#262680">check-type</font> <font color="#262680"><i>vrb</i></font> <font color="#218C21">"intransitive &nbsp;verb"</font><font color="#853D24">)</font> <br><font color="#853D24"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</font>lambda<font color="#853D24"> &nbsp;() </font><font color="#262680"><i>expr</i></font><font color="#853D24"> ))</font> <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<font color="#853D24">)))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font>define-syntax <font color="#262680"><i>id</i></font><font color="#853D24"> &nbsp;(</font><font color="#262680">typed</font> #'<font color="#262680"><i>gen-id</i></font> <font color="#218C21">"place"</font><font color="#853D24">))</font> <br><font color="#853D24"> &nbsp; &nbsp; (</font><font color="#262680">record-element!</font> <font color="#218C21">'</font><font color="#262680"><i>id id</i></font><font color="#853D24"> )))</font> <br></p>
<p>The <font face="Courier New">define-one-verb</font> macro must change to similarly declare each verb as either type <font face="Courier New">"transitive verb"</font> or <font face="Courier New">"intransitive verb"</font>. The <font face="Courier New">define-thing</font> macro changes to declare its binding as a <font face="Courier New">"thing"</font>, and it checks that each handled verb is defined as a <font face="Courier New">"transitive verb"</font>.</p>
<p>The code for the game with static checks is available online: </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/4-type/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/4-type/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/4-type/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/4-type/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/4-type/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/4-type/README.txt</a> <br> </p>
<p>The implementation of <font face="Courier New">check-form</font> uses <font face="Courier New">syntax-case</font>, which provides the pattern-matching functionality of <font face="Courier New">syntax-rules</font>, but pairs each pattern with an expression rather than a fixed template.</p>
<h3>New Syntax</h3>
<p>A Racket programmer who defines a custom text-adventure language for other Racket programmers is especially likely to stop at this point. If the text-adventure language is to be used by others who are less familiar with Racket, however, a different notation may be appropriate. For example, others may prefer a notation such as the following from world.rkt:</p>
<p style="font-family:monospace;font-size:1.1em;"> #lang <font color="#262680">reader</font><font> &nbsp;</font><font color="#218C21">"txtadv-reader.rkt"</font> <br> <br><font color="#262680">===VERBS===</font> <br><font color="#262680">north</font><font>,</font><font color="#262680"> &nbsp;n</font> <br><font color="#218C21"> &nbsp;"go &nbsp;north"</font> <br><font color="#262680">get </font><font>_,</font><font color="#262680"> &nbsp;grab </font><font>_,</font><font color="#262680"> &nbsp;take </font><font>_</font> <br><font color="#262680"> &nbsp;</font><font color="#218C21">"take"</font> <br><font color="#262680">....</font> <br><font color="#262680">===EVERYWHERE===</font> <br><font color="#262680">save</font> <br><font color="#262680"> &nbsp;</font><font color="#853D24">(</font><font color="#262680">save-game</font><font color="#853D24">)</font> <br><font color="#262680">load</font> <br><font color="#853D24"> &nbsp;(</font><font color="#262680">load-game</font><font color="#853D24">)</font> <br><font color="#262680">....</font> <br><font color="#262680">===THINGS===</font> <br><font color="#262680">---cactus---</font> <br><font color="#262680">get</font> <br><font color="#262680"> &nbsp;</font><font color="#218C21">"Ouch!"</font> <br><font color="#262680">....</font> <br><font color="#262680">===PLACES===</font> <br><font color="#262680">---desert---</font> <br><font color="#218C21">"You're &nbsp;in a desert."</font> <br><font color="#853D24"> &nbsp;[</font><font color="#262680">cactus</font><font>,</font> <font color="#262680">key</font><font color="#853D24">]</font> <br><font color="#262680">north &nbsp; &nbsp;start</font> <br><font color="#262680">south &nbsp; &nbsp;desert</font> <br><font color="#262680">....</font> <br></p>
<p>In this notation, instead of forms such as <font face="Courier New">define-verbs</font> and <font face="Courier New">define-everywhere</font>, sections of the program are introduced by tags such as <font face="Courier New">===VERBS===</font> and <font face="Courier New">===EVERYWHERE===</font>. Names in the <font face="Courier New">===VERBS===</font> section implicitly define verbs, listing aliases afterward through a comma-separated sequence followed by an optional description of the verb. Similarly, each name in the <font face="Courier New">===EVERYWHERE===</font> section implicitly defines the response to a verb; the responses are still written as Racket expressions, but they could be in any alternate notation, if desired. Each thing and place is defined by its own subsection, such as <font face="Courier New">---cactus---</font>, with per-object verb responses in the same way as in <font face="Courier New">===EVERYWHERE===</font>.</p>
<p>Non-S-expression syntax is enabled in world.rkt by starting with <font face="Courier New">#lang reader "txtadv-reader.rkt"</font> instead of <font face="Courier New">#lang s-exp "txtadv.rkt"</font>. The <font face="Courier New">reader</font> language constructor, unlike the <font face="Courier New">s-exp</font> language constructor, defers parsing of the program's text to an arbitrary parsing function that is exported by the named module, which in this case is <font face="Courier New">txtadv-reader.rkt</font>. The parser from <font face="Courier New">txtadv-reader.rkt</font> is responsible for processing the rest of the text and converting it into S-expression notation, including the introduction of <font face="Courier New">txtadv.rkt</font> as the module language for the parsed <font face="Courier New">world.rkt</font> module.</p>
<p>More precisely, a reader function parses input into a syntax object, which is like an S-expression that is enriched with lexical-context and source-location information. It also acts as the representation of code for macro-transformer arguments and results. The syntax-object abstraction provides a clean separation of character-level parsing and tree-structured macro transformations. The source-location part of a syntax object automatically connects the result of macro expansion back to the original source; if a runtime error occurs in the code generated from <font face="Courier New">world.rkt</font>, then the error can point back to the relevant source.</p>
<p>The game code with nonparentheses syntax is available online: </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/txtadv-reader.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/txtadv-reader.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/world.rkt</a></p>
<p><a href="https://queue.acm.org/downloads/2011/racket/5-lang/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/5-lang/README.txt</a> <br> </p>
<p>The parser in <font face="Courier New">txtadv-reader.rkt</font> is implemented in an especially primitive way with regular expressions. The Racket distribution includes better parsing tools such as Lex- and Yacc-style parser generators.</p>
<h3>IDE Support</h3>
<p>One of the benefits of S-expression notation is that a programming environment's functionality adapts easily to syntactic extension, since syntax coloring and parentheses matching can be independent of macro expansion. Some of those benefits are intact with the new syntax for describing a world, since the parser keeps source locations with identifiers and since the code ultimately expands to Racket-level binding forms. For example, the Check Syntax button in DrRacket can automatically draw arrows from the binding instance of <font face="Courier New">cactus</font> to each bound use of <font face="Courier New">cactus</font>.</p>
<p>DrRacket needs more help from the language implementer for IDE features, such as syntax coloring, that depend on the character-level syntax of the language. Filling in this piece of the sample text-adventure language takes two steps:</p>
<p>1. Install the language's reader as a <font face="Courier New">txtadv</font> library collection instead of relying on a relative path such as <font face="Courier New">txtadv-reader.rkt</font>. Moving to the namespace of library collections allows DrRacket and the program to agree on which language is being used (without requiring project-style configuration of the IDE).</p>
<p>2. Add a function to the <font face="Courier New">txtadv</font> reader module that identifies additional support for the language, such as a module that implements on-the-fly syntax coloring. Again, since DrRacket and the module use the same specification of the module's language, the syntax color can be precisely tailored to the module's language and content. </p>
<p>The code for the game with a DrRacket plug-in for syntax coloring is available online: </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/txtadv.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/txtadv.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/world.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/world.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/README.txt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/README.txt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/lang/color.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/lang/color.rkt</a> </p>
<p><a href="https://queue.acm.org/downloads/2011/racket/6-color/lang/reader.rkt" target="_blank">http://queue.acm.org/downloads/2011/racket/6-color/lang/reader.rkt</a> </p>
<p>This plug-in colors the program according to the game language's syntax instead of Racket's default rules, highlighting lexical syntax errors in red.</p>
<h3>More Languages</h3>
<p>The source code of the Racket distribution includes dozens of unique <font face="Courier New">#lang</font> lines. The most common is <font face="Courier New">#lang racket/base</font>, a stripped-down variant of <font face="Courier New">#lang racket</font>. Other common lines include <font face="Courier New">#lang scribble/manual</font> for documentation sources, <font face="Courier New">#lang racket/unit</font> for externally linkable components, <font face="Courier New">#lang scheme</font> for legacy modules, and <font face="Courier New">#lang setup/infotab</font> for library metadata. Most Racket languages use S-expression notation, but <font face="Courier New">scribble/manual</font> is a notable exception; even parentheses-loving Racketeers concede that an S-expression is a poor notation for documentation prose.</p>
<p>Different languages in the Racket distribution exist for different reasons, and they use Racket's language-creation facilities to different degrees. Racket developers do not create new languages lightly, but the benefits of a new language sometimes outweigh the cost of learning a language variant. These benefits are as readily available to Racket users as to the core Racket developers.</p>
<p>Racket's support for S-expression languages and language extensions is particularly rich, and the examples in this article only scratch the surface of that toolbox. Racket's toolbox for non-S-expression syntax is still evolving, especially with respect to composable parsers and language-triggered IDE plug-ins. Fortunately, Racket's <font face="Courier New">#lang</font> protocol moves most of the remaining work out of the core system and into libraries. This means that Racket users are as empowered as core Racket developers to develop improved syntax tools.</p>
</div>
</body></html>